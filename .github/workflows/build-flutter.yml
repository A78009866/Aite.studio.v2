name: Smart Flutter Cloud Build (Z.AI Powered)

on:
  repository_dispatch:
    types: [build-flutter]
  workflow_dispatch:
    inputs:
      app_name:
        description: 'App Name'
        required: true
      package_name:
        description: 'Package Name'
        required: true
      icon_url:
        description: 'Icon URL'
        required: true
      zip_url:
        description: 'Project ZIP URL'
        required: true

env:
  PROJECT_DIR: ${{ github.workspace }}/flutter_project
  BUILD_ID: ${{ github.event.client_payload.request_id || github.run_id }}
  APP_NAME: ${{ github.event.client_payload.app_name || github.event.inputs.app_name }}
  SAFE_NAME: ${{ github.event.client_payload.safe_name || 'app-release' }}
  PACKAGE_NAME: ${{ github.event.client_payload.package_name || github.event.inputs.package_name }}
  ICON_URL: ${{ github.event.client_payload.icon_url || github.event.inputs.icon_url }}
  ZIP_URL: ${{ github.event.client_payload.zip_url || github.event.inputs.zip_url }}
  # Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Z.AI (ZhipuAI)
  AI_BASE_URL: "https://open.bigmodel.cn/api/paas/v4/chat/completions"
  AI_MODEL: "glm-4" 

jobs:
  analyze-and-build:
    runs-on: ubuntu-latest
    timeout-minutes: 60
    permissions:
      contents: write
    
    steps:
      - name: Setup Environment
        run: |
          sudo apt-get update -qq
          sudo apt-get install -y -qq wget unzip imagemagick sed curl

      - name: Setup Java
        uses: actions/setup-java@v4
        with:
          distribution: 'temurin'
          java-version: '17'

      - name: Setup Flutter
        uses: subosito/flutter-action@v2
        with:
          channel: 'stable'
          cache: true

      - name: Download Project
        run: |
          wget -q --show-progress -O project.zip "$ZIP_URL"
          mkdir -p $PROJECT_DIR
          unzip -q project.zip -d temp_extract
          if [ "$(ls -A temp_extract | wc -l)" == "1" ] && [ -d "temp_extract/$(ls -A temp_extract)" ]; then
            mv temp_extract/*/* $PROJECT_DIR/
          else
            mv temp_extract/* $PROJECT_DIR/
          fi
          rm -rf temp_extract project.zip

      - name: Basic Fixes & Config
        working-directory: ${{ env.PROJECT_DIR }}
        run: |
          echo "storePassword=android" > android/key.properties
          echo "keyPassword=android" >> android/key.properties
          echo "keyAlias=androiddebugkey" >> android/key.properties
          echo "storeFile=../debug.keystore" >> android/key.properties

          cd android
          keytool -genkey -v -keystore debug.keystore -storepass android -alias androiddebugkey -keypass android -keyalg RSA -keysize 2048 -validity 10000 -dname "CN=Android Debug,O=Android,C=US"
          cd ..

          if [ ! -f "android/app/google-services.json" ]; then
             echo '{"project_info":{"project_number":"0","project_id":"dummy","storage_bucket":"dummy"},"client":[{"client_info":{"mobilesdk_app_id":"1:0:android:0","android_client_info":{"package_name":"'"$PACKAGE_NAME"'"}},"api_key":[{"current_key":"dummy"}]}]}' > android/app/google-services.json
          fi

          rm -rf android/app/src/main/res/mipmap-*
          wget -q -O icon.png "$ICON_URL"
          mkdir -p android/app/src/main/res/mipmap-xxhdpi
          convert icon.png -resize 144x144 android/app/src/main/res/mipmap-xxhdpi/ic_launcher.png

          if [ -f "pubspec.yaml" ]; then
            sed -i 's/sdk: ">=2.0.[0-9].*"/sdk: ">=2.12.0 <4.0.0"/' pubspec.yaml || true
          fi

      - name: First Build Attempt
        id: build_1
        working-directory: ${{ env.PROJECT_DIR }}
        continue-on-error: true
        run: |
          flutter pub get
          flutter build apk --release --no-android-gradle-daemon > build_log.txt 2>&1
        
      - name: AI Auto-Fix (Z.AI Powered)
        if: steps.build_1.outcome == 'failure'
        working-directory: ${{ env.PROJECT_DIR }}
        env:
          OPENAI_API_KEY: ${{ secrets.AI_API_KEY }}
          AI_BASE_URL: ${{ env.AI_BASE_URL }}
          AI_MODEL: ${{ env.AI_MODEL }}
        run: |
          echo "âŒ Build Failed. Starting Z.AI Repair..."
          
          cat > ai_repair.js << 'EOF'
          const fs = require('fs');
          const https = require('https');
          const { URL } = require('url');

          const API_KEY = process.env.OPENAI_API_KEY;
          const BASE_URL = process.env.AI_BASE_URL; // e.g. https://open.bigmodel.cn/api/paas/v4/chat/completions
          const MODEL = process.env.AI_MODEL || "glm-4";

          if (!API_KEY) { console.error("No API Key found!"); process.exit(1); }

          async function callAI(prompt) {
            const endpoint = new URL(BASE_URL);
            
            const postData = JSON.stringify({
              model: MODEL,
              messages: [
                { role: "system", content: "You are a senior Flutter DevOps engineer. You fix build errors by correcting 'pubspec.yaml' and 'android/build.gradle'. Return ONLY the full corrected file content within code blocks." },
                { role: "user", content: prompt }
              ],
              temperature: 0.1
            });

            return new Promise((resolve, reject) => {
              const req = https.request({
                hostname: endpoint.hostname,
                path: endpoint.pathname + endpoint.search,
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                  'Authorization': `Bearer ${API_KEY}`
                }
              }, (res) => {
                let body = '';
                res.on('data', d => body += d);
                res.on('end', () => {
                  try {
                    const parsed = JSON.parse(body);
                    if(parsed.error) reject(JSON.stringify(parsed.error));
                    else if(parsed.choices && parsed.choices[0]) resolve(parsed.choices[0].message.content);
                    else reject("Invalid response format: " + body);
                  } catch(e) { reject(e); }
                });
              });
              req.on('error', reject);
              req.write(postData);
              req.end();
            });
          }

          function extractCode(response) {
            // ØªÙ†Ø¸ÙŠÙ Ø§Ù„Ù†Øµ Ù„Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„ÙƒÙˆØ¯ ÙÙ‚Ø·
            const match = response.match(/```(?:yaml|gradle|groovy)?\n([\s\S]*?)\n```/);
            return match ? match[1] : response;
          }

          async function main() {
            const log = fs.readFileSync('build_log.txt', 'utf8').slice(-3500);
            const pubspec = fs.readFileSync('pubspec.yaml', 'utf8');
            let gradle = "";
            try { gradle = fs.readFileSync('android/app/build.gradle', 'utf8'); } catch(e){}

            console.log(`ğŸ¤– Consulting Z.AI (${MODEL})...`);

            // 1. Ø¥ØµÙ„Ø§Ø­ Pubspec
            if (log.includes("version solving failed") || log.includes("Error: Method not found") || log.includes("depends on")) {
                console.log("Fixing pubspec.yaml...");
                const prompt = `Fix this Flutter dependency error (resolve version conflicts).\n\nERROR LOG:\n${log}\n\nCURRENT PUBSPEC:\n${pubspec}\n\nOUTPUT: Full corrected pubspec.yaml only.`;
                try {
                    const newPubspec = extractCode(await callAI(prompt));
                    if(newPubspec.length > 50) {
                        fs.writeFileSync('pubspec.yaml', newPubspec);
                        console.log("âœ… pubspec.yaml updated.");
                    }
                } catch(err) { console.error("Z.AI Error (Pubspec):", err); }
            }

            // 2. Ø¥ØµÙ„Ø§Ø­ Gradle (Ù…Ø´ÙƒÙ„Ø© Kotlin Ø§Ù„ØªÙŠ Ø¸Ù‡Ø±Øª ÙÙŠ Ø³Ø¬Ù„Ùƒ)
            if (log.includes("Namespace") || log.includes("Gradle") || log.includes("minSdkVersion") || log.includes("Kotlin")) {
                console.log("Fixing build.gradle...");
                const prompt = `Fix this Android Gradle error. Ensure 'namespace' is defined. Fix Kotlin version mismatch if mentioned.\n\nERROR LOG:\n${log}\n\nCURRENT GRADLE:\n${gradle}\n\nOUTPUT: Full corrected android/app/build.gradle only.`;
                try {
                    const newGradle = extractCode(await callAI(prompt));
                    if(newGradle.length > 50) {
                        fs.writeFileSync('android/app/build.gradle', newGradle);
                        console.log("âœ… build.gradle updated.");
                    }
                } catch(err) { console.error("Z.AI Error (Gradle):", err); }
            }
          }

          main().catch(console.error);
          EOF

          node ai_repair.js
          
          flutter clean
          flutter pub get

      - name: Retry Build (After AI Fix)
        if: steps.build_1.outcome == 'failure'
        working-directory: ${{ env.PROJECT_DIR }}
        run: |
          echo "ğŸ”„ Retrying build after AI fixes..."
          flutter build apk --release --no-android-gradle-daemon

      - name: Prepare Artifact
        id: prepare_artifact
        run: |
          APK_PATH=$(find $PROJECT_DIR/build/app/outputs/flutter-apk -name "*.apk" -not -name "*-unsigned.apk" | head -n 1)
          if [ -f "$APK_PATH" ]; then
            echo "âœ… Build Success!"
            mv "$APK_PATH" "$PROJECT_DIR/${SAFE_NAME}.apk"
            echo "FINAL_APK=$PROJECT_DIR/${SAFE_NAME}.apk" >> $GITHUB_ENV
          else
            echo "âŒ Build Failed."
            exit 1
          fi

      - name: Upload Release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: build-${{ env.BUILD_ID }}
          name: "${{ env.APP_NAME }}"
          body: |
            âœ… **ØªÙ… Ø§Ù„Ø¨Ù†Ø§Ø¡ Ø¨Ù†Ø¬Ø§Ø­** (Z.AI Powered)
            ğŸ“± **Ø§Ù„ØªØ·Ø¨ÙŠÙ‚:** ${{ env.APP_NAME }}
            âœ¨ **ØªÙ… Ø§Ù„Ø¥ØµÙ„Ø§Ø­ Ø§Ù„Ø°Ø§ØªÙŠ:** ${{ steps.build_1.outcome == 'failure' }}
          files: ${{ env.FINAL_APK }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
